<!doctype html>
<html lang="ru">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>mysql and postgresql</title>

    <link rel="stylesheet" href="reveal.js/dist/reset.css">
    <link rel="stylesheet" href="reveal.js/dist/reveal.css">
    <link rel="stylesheet" href="reveal.js/dist/theme/sky.css">
    <link rel="stylesheet" href="styles.css">

    <!-- Theme used for syntax highlighted code -->
    <link rel="stylesheet" href="reveal.js/plugin/highlight/zenburn.css">
</head>
<body>
<div class="reveal">
    <div class="slides">
        <section>
            <a href="https://digital-spectr.ru/event/perm-dev-meetup-1" target="_blank"><img
                    src="static/img/meetup_logo.png" alt="{Perm} DEV Meetup #1"></a>
            <h3>MySQL и PostgreSQL</h3>
            <p>что «под капотом» и почему это важно знать прикладному разработчику</p>

            <footer>Никита Стрелков, разработчик e-commerce-подразделения, VK</footer>
            <a href="https://digital-spectr.ru/" target="_blank">
                <img src="static/img/org_1.png" alt="DigitalSpectr"></a>
            <a href="https://tagline.ru/" target="_blank">
                <img src="static/img/org_2.png" alt="Tagline">
            </a>
        </section>

        <section>
            <h3>Обо мне</h3>
            <p>Никита Стрелков<br>Разработчик в проекте PayDay</p>
            <ul>
                <li>Go/PHP разработчик</li>
                <li>8+ лет в программировании, весь продакшен опыт на backend</li>
                <li>ведущий преподаватель курса СУБД в Технопарке МГТУ им. Баумана</li>
                <li><a href="mailto:nikita.strelkov@gmail.com">nikita.strelkov@gmail.com</a></li>
                <li>Telegram: <a href="https://t.me/nikitastrelkov">@NikitaStrelkov</a></li>
            </ul>
            <aside class="notes">
                Go/PHP разработчик, 8+ лет в программировании, backend разработчик подчеркнуть
                Попеременно работал в проектах то с PG, то с Mysql
                В VK (бывший MRG) пришел в проект, в котором рядом мирно сосуществовали Mysql-oltp и PG-olap. Последние
                3 года в проде только PG.
                Также я являюсь ведущим преподавателем семестрового курса СУБД в Технопарке МГТУ им. Баумана проекта VK
                Education
            </aside>
        </section>

        <section>
            <h3>О чем доклад</h3>
            <ul>
                <li>Сравнение функций</li>
                <li>Процессная/потоковая модель сервера</li>
                <li>Путь выполнения запроса</li>
                <li>Реализация требований ACID</li>
                <li>B-Tree индексы</li>
            </ul>
            <aside class="notes">
            </aside>
        </section>

        <section>
            <h3 class="slide-header">Почему?</h3>
            <ul>
                <li>MySQL и PostgreSQL одни из самых популярных реляционных СУБД</li>
                <li>Многим в течение карьеры сталкиваются с необходимостью</li>
                <li></li>
            </ul>
            <aside class="notes">Так как Mysql и PG одни из самых популярных реляционных субд, многим разработчикам в
                течение карьеры приходится
                либо вставать перед выбором субд для нового проекта или его части,
                либо переходить с одной субд на другую,
                либо даже работать с обеими одновременно
                Поэтому Я СЧИТАЮ, что хорошо бы знать про отличительные особенности этих СУБД
            </aside>
        </section>

        <section>
            <h3>Сравнение функций</h3>
            <table>
                <thead>
                <tr>
                    <th>PostgreSQL</th>
                    <th>MySQL</th>
                </tr>
                </thead>
                <tbody>
                <tr>
                    <td>Объектно-реляционная СУБД</td>
                    <td>Реляционная СУБД</td>
                </tr>
                </tbody>
            </table>
            <aside class="notes">Если погуглить про разницу, то большинство статей и роликов на youtube будут
                ограничиваться сравнением набора фич.
                И если ставить вопрос именно о выборе субд для своего проекта, то этого критерия было достаточно для
                маленьких и средних проектов.
            </aside>
        </section>

        <section>
            <h3>Сравнение функций</h3>
            <table class="r-fit-text">
                <thead>
                <tr>
                    <th>Функция</th>
                    <th>PostgreSQL 14+</th>
                    <th>MySQL 8+</th>
                </tr>
                </thead>
                <tbody>
                <tr>
                    <td>CTE</td>
                    <td>Есть</td>
                    <td>Есть</td>
                </tr>
                <tr>
                    <td>Декларативное секционирование</td>
                    <td>Есть</td>
                    <td>Есть</td>
                </tr>
                <tr>
                    <td>Полнотекстовый поиск</td>
                    <td>Есть</td>
                    <td>Есть</td>
                </tr>
                <tr>
                    <td>GIS и SRS</td>
                    <td>Есть</td>
                    <td>Есть</td>
                </tr>
                <tr>
                    <td>JSON</td>
                    <td>Есть</td>
                    <td>Есть</td>
                </tr>
                <tr>
                    <td>Логическая репликация</td>
                    <td>Есть</td>
                    <td>Есть</td>
                </tr>
                <tr>
                    <td>Полусинхронная репликация</td>
                    <td>Есть</td>
                    <td>Есть</td>
                </tr>
                <tr>
                    <td>Оконные функции</td>
                    <td>Есть</td>
                    <td>Есть</td>
                </tr>
                </tbody>
            </table>
            <aside class="notes">
                Было раньше.
                На протяжении многих все сравнение и муки выбора можно было сводить просто к выбору нужной фичи, но
                внезапно за последние несколько лет основная функциональность этих СУБД примерно выравнялась.
                ДА, надо понимать, что работают эти фичи тоже с разной эффективностью и со своими особенностями.
                Но ключевой момент в том, что сравнивать субд и делать выбор просто по наличию нужной фичи сегодня
                некорректно, и нужно смотреть глубже
            </aside>
        </section>

        <section>
            <h3 class="slide-header">Процессы и потоки</h3>
            <img class="r-stretch" src="static/img/pg_process_model.png" alt="postgres process model"/>
            <aside class="notes">
                Под понятием "PostgreSQL server" обычно подразумевается набор процессов:
                <ul>
                    <li>Процесс "postgres server" (ранее postmaster), являющийся родительским для всех остальных
                        процессов
                    </li>
                    <li>Процессы postgres backend", которые создаются под каждое соединение</li>
                    <li>Набор служебных процессов, отвечающих за разные компоненты и функции сервера</li>
                    <li>А взаимодействуют они все через общую память</li>
                </ul>
            </aside>
        </section>

        <section>
            <h3 class="slide-header">Процессы PostgreSQL</h3>
            <pre><code class="language-plaintext" style="font-size: 11pt" data-line-numbers="|1-3|10-11|4-9">$ pstree -p 43545
-+= 00001 root /sbin/launchd
 \-+= 43545 n.strelkov /usr/local/bin/postgres -D /usr/local/var/postgres
   |--= 43547 n.strelkov postgres: checkpointer
   |--= 43548 n.strelkov postgres: background writer
   |--= 43549 n.strelkov postgres: walwriter
   |--= 43550 n.strelkov postgres: autovacuum launcher
   |--= 43551 n.strelkov postgres: stats collector
   |--= 43552 n.strelkov postgres: logical replication launcher
   |--= 48886 n.strelkov postgres: n.strelkov postgres [local] idle
   \--= 49086 n.strelkov postgres: n.strelkov movielens [local] idle in transaction
            </code></pre>
            <aside class="notes">
                The actual processes of a PostgreSQL server is shown here. In the following example, one postgres server
                process (pid is 9687), two backend processes (pids are 9697 and 9717) and the several background
                processes listed in Table 2.1 are running.
            </aside>
        </section>

        <section>
            <h3 class="slide-header">Процессы MySQL</h3>
            <pre><code class="language-plaintext" style="font-size: 14pt" data-line-numbers="|3-4|5-11">$ pstree -p 50249
-+= 00001 root /sbin/launchd
 \-+= 50136 n.strelkov /bin/sh /usr/local/opt/mysql/bin/mysqld_safe \
                --datadir=/usr/local/var/mysql
   \--- 50249 n.strelkov /usr/local/opt/mysql/bin/mysqld \
                --basedir=/usr/local/opt/mysql \
                --datadir=/usr/local/var/mysql \
                --plugin-dir=/usr/local/opt/mysql/lib/plugin \
                --log-error=n-strelkov.err \
                --pid-file=n-strelkov.pid
            </code></pre>
            <aside class="notes"></aside>
        </section>

        <section>
            <h3 class="slide-header">Потоки MySQL</h3>
            <pre><code class="language-plaintext" style="font-size: 10pt" data-line-numbers="|2-10|11-19|20-29|21">mysql> show processlist\G
*************************** 1. row ***************************
     Id: 5
   User: event_scheduler
   Host: localhost
     db: NULL
Command: Daemon
   Time: 539
  State: Waiting on empty queue
   Info: NULL
*************************** 2. row ***************************
     Id: 8
   User: root
   Host: localhost
     db: NULL
Command: Query
   Time: 0
  State: init
   Info: show processlist
*************************** 3. row ***************************
     Id: 9
   User: root
   Host: localhost
     db: NULL
Command: Sleep
   Time: 437
  State:
   Info: NULL
3 rows in set (0.00 sec)</code></pre>
            <aside class="notes"></aside>
        </section>

        <section>
            <h3 class="slide-header">MySQL</h3>
            <p>Connection ID</p>
            <pre><code class="language-plaintext" data-line-numbers="|3">mysql> select connection_id()\G
*************************** 1. row ***************************
connection_id(): 8
1 row in set (0.01 sec)</code></pre>
            <aside class="notes"></aside>
        </section>

        <section>
            <h3 class="slide-header">MySQL</h3>
            <p>количество активных потоков</p>
            <pre><code class="language-plaintext" data-line-numbers="|3-4">mysql> show global status like 'threads_running'\G
*************************** 1. row ***************************
Variable_name: Threads_running
        Value: 2
1 row in set (0.00 sec)</code></pre>
            <aside class="notes"></aside>
        </section>

        <section>
            <h3 class="slide-header">Connection pool</h3>
            <table class="r-fit-text">
                <thead>
                <tr>
                    <th>PostgreSQL</th>
                    <th>MySQL</th>
                </tr>
                </thead>
                <tbody>
                <tr>
                    <td><a href="https://www.pgpool.net/">PGPool-II</a> <br>и/или<br> <a
                            href="https://www.pgbouncer.org/">PgBouncer</a></td>
                    <td>Client-side<br>connection pool</td>
                </tr>

                </tbody>

            </table>
            <aside class="notes">Не забывать настраивать пулл соединений с СУБД<br>
                Для PG в качестве прослойки обычно используются вот эти две утилиты<br>
                причем можно по отдельности, а можно и вместе, так как они имеют свои особенности и ограничения<br>
                А для MySQL сервер умеет кэшировать однажды выделенные на соединение потоки, поэтому тут нужно просто
            </aside>
        </section>

        <section>
            <h3 class="slide-header">Путь запроса PostgreSQL</h3>
            <img class="r-stretch" src="static/img/pg_query_path.png" alt="pg query path">
            <aside class="notes">
                <ol>
                    <li>Прикладная программа устанавливает подключение к серверу PostgreSQL. Эта программа передаёт
                        запрос на сервер и ждёт от него результатов.
                    </li>

                    <li>На этапе разбора запроса сервер выполняет синтаксическую проверку запроса, переданного
                        прикладной программой, и создаёт дерево запроса.
                    </li>

                    <li>Система правил принимает дерево запроса, созданное на стадии разбора, и ищет в системных
                        каталогах правила для применения к этому дереву.
                        Обнаружив подходящие правила, она выполняет преобразования, заданные в теле правил.
                        Одно из применений системы правил заключается в реализации представлений. Когда выполняется
                        запрос к представлению (т. е. виртуальной таблице),
                        система правил преобразует запрос пользователя в запрос, обращающийся не к представлению, а к
                        базовым таблицам из определения представления.
                    </li>

                    <li>Планировщик/оптимизатор принимает дерево запроса (возможно, переписанное) и создаёт план
                        запроса, который будет передан исполнителю.
                        Он выбирает план, сначала рассматривая все возможные варианты получения одного и того же
                        результата.
                        Например, если для обрабатываемого отношения создан индекс, прочитать отношение можно двумя
                        способами.
                        Во-первых, можно выполнить простое последовательное сканирование,
                        а во-вторых, можно использовать индекс.
                        Затем оценивается стоимость каждого варианта и выбирается самый дешёвый.
                        Затем выбранный вариант разворачивается в полноценный план, который сможет использовать
                        исполнитель.
                    </li>

                    <li>Исполнитель рекурсивно проходит по дереву плана и получает строки тем способом, который указан в
                        плане.
                        Он сканирует отношения, обращаясь к системе хранения, выполняет сортировку и соединения,
                        вычисляет условия фильтра и, наконец, возвращает полученные строки.
                    </li>
                </ol>

            </aside>
        </section>

        <section>
            <h3 class="slide-header">Путь запроса MySQL</h3>
            <img class="r-stretch" src="static/img/mysql_query_path.png" alt="mysql query path">
            <aside class="notes"></aside>
        </section>

        <section>
            <h3 class="slide-header"></h3>
            <aside class="notes"></aside>
        </section>
    </div>
</div>

<script src="reveal.js/dist/reveal.js"></script>
<script src="reveal.js/plugin/notes/notes.js"></script>
<script src="reveal.js/plugin/markdown/markdown.js"></script>
<script src="reveal.js/plugin/highlight/highlight.js"></script>
<script>
    // More info about initialization & config:
    // - https://revealjs.com/initialization/
    // - https://revealjs.com/config/
    Reveal.initialize({
        hash: true,

        // Learn about plugins: https://revealjs.com/plugins/
        plugins: [RevealMarkdown, RevealHighlight, RevealNotes],

        slideNumber: 'c',
        showSlideNumber: 'all',
    });
</script>
</body>
</html>
