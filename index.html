<!doctype html>
<html lang="ru">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>mysql and postgresql</title>

    <link rel="stylesheet" href="reveal.js/dist/reset.css">
    <link rel="stylesheet" href="reveal.js/dist/reveal.css">
    <link rel="stylesheet" href="reveal.js/dist/theme/sky.css">
    <link rel="stylesheet" href="styles.css">

    <!-- Theme used for syntax highlighted code -->
    <link rel="stylesheet" href="reveal.js/plugin/highlight/zenburn.css">
</head>
<body>
<div class="reveal">
    <div class="slides">
        <section>
            <a href="https://digital-spectr.ru/event/perm-dev-meetup-1" target="_blank"><img
                    src="static/img/meetup_logo.png" alt="{Perm} DEV Meetup #1"></a>
            <h3>MySQL и PostgreSQL</h3>
            <p>что «под капотом» и почему это важно знать прикладному разработчику</p>

            <footer style="font-size: 20pt">Никита Стрелков, разработчик e-commerce подразделения, VK</footer>
            <!--            <a href="https://digital-spectr.ru/" target="_blank">-->
            <!--                <img src="static/img/org_1.png" alt="DigitalSpectr"></a>-->
            <!--            <a href="https://tagline.ru/" target="_blank">-->
            <!--                <img src="static/img/org_2.png" style="max-width: 30%" alt="Tagline">-->
            <!--            </a>-->
        </section>

        <section>
            <h3 class="slide-header">Обо мне</h3>
            <p>Никита Стрелков<br>Разработчик в проекте PayDay</p>
            <ul>
                <li>Go/PHP разработчик</li>
                <li>8+ лет в программировании, весь продакшен опыт на backend</li>
                <li>ведущий преподаватель курса СУБД в Технопарке МГТУ им. Баумана</li>
                <li><a href="mailto:nikita.strelkov@gmail.com">nikita.strelkov@gmail.com</a></li>
                <li>Telegram: <a href="https://t.me/nikitastrelkov">@NikitaStrelkov</a></li>
            </ul>
            <aside class="notes">
                Go/PHP разработчик, 8+ лет в программировании, backend разработчик подчеркнуть
                Попеременно работал в проектах то с PG, то с Mysql
                В VK (бывший MRG) пришел в проект, в котором рядом мирно сосуществовали Mysql-oltp и PG-olap. Последние
                3 года в проде только PG.
                Также я являюсь ведущим преподавателем семестрового курса СУБД в Технопарке МГТУ им. Баумана проекта VK
                Education
            </aside>
        </section>

        <section>
            <h3 class="slide-header">О чем доклад</h3>
            <ul>
                <li>Сравнение функциональности</li>
                <li>Процессная/потоковая модель сервера</li>
                <li>Путь выполнения запроса</li>
                <li>MVCC</li>
                <li>Индексы</li>
            </ul>
            <aside class="notes">
                Надо понимать, что СУБД - это очень комплексные и сложные системы, с большим количеством компонентов и
                уровней абстракций.<br>
                И если смотреть совсем вглубь, то, конечно, окажется, что различий очень много и за 40минутный доклад
                такой объем информации не охватить.<br>
                Поэтому я решил ограничиться вот таким набором тем, которые по МОЕМУ ЛИЧНОМУ СУБЪЕТКИВНОМУ МНЕНИЮ
                являются очень важными для сравнения.
            </aside>
        </section>

        <section>
            <h3 class="r-fit-text">Почему, а главное зачем?</h3>
            <aside class="notes">Так как Mysql и PG одни из самых популярных реляционных субд, многим разработчикам в
                течение карьеры приходится
                либо вставать перед выбором субд для нового проекта или его части,
                либо переходить с одной субд на другую,
                либо даже работать с обеими одновременно
                Поэтому Я СЧИТАЮ, что хорошо бы знать про отличительные особенности этих СУБД

                И тут еще небольшая оговорка, из-за того, что я в последние несколько лет и в проде использую постгрес и
                курс для студентов у нас построен тоже вокруг него,<br>
                свое повествование я буду строить немного относительно постгреса, не сочтите это за предвзятость, <br>
                у меня нет цели сравнить плюсы и минусы и назвать победителя
            </aside>
        </section>

        <section>
            <h3 class="slide-header">Сравнение функциональности</h3>
            <table class="r-fit-text">
                <thead>
                <tr>
                    <th>Функция</th>
                    <th>PostgreSQL 14+</th>
                    <th>MySQL 8+</th>
                </tr>
                </thead>
                <tbody>
                <tr>
                    <td>CTE</td>
                    <td>Есть</td>
                    <td>Есть</td>
                </tr>
                <tr>
                    <td>Декларативное секционирование</td>
                    <td>Есть</td>
                    <td>Есть</td>
                </tr>
                <tr>
                    <td>Полнотекстовый поиск</td>
                    <td>Есть</td>
                    <td>Есть</td>
                </tr>
                <tr>
                    <td>GIS и SRS</td>
                    <td>Есть</td>
                    <td>Есть</td>
                </tr>
                <tr>
                    <td>JSON</td>
                    <td>Есть</td>
                    <td>Есть</td>
                </tr>
                <tr>
                    <td>Логическая репликация</td>
                    <td>Есть</td>
                    <td>Есть</td>
                </tr>
                <tr>
                    <td>Полусинхронная репликация</td>
                    <td>Есть</td>
                    <td>Есть</td>
                </tr>
                <tr>
                    <td>Оконные функции</td>
                    <td>Есть</td>
                    <td>Есть</td>
                </tr>
                <tr>
                    <td>Tранзакционный DDL</td>
                    <td>Есть</td>
                    <td>Есть</td>
                </tr>
                </tbody>
            </table>
            <aside class="notes">
                Если погуглить про разницу, то большинство статей и роликов на youtube будут
                ограничиваться сравнением набора фич.
                И если ставить вопрос именно о выборе субд для своего проекта, то этого критерия было достаточно для
                маленьких и средних проектов.
                Но то было раньше.
                На протяжении многих все сравнение и муки выбора можно было сводить просто к выбору нужной фичи, но
                внезапно за последние несколько лет основная функциональность этих СУБД примерно сравнялась.
                ДА, надо понимать, что работают эти фичи тоже с разной эффективностью и со своими особенностями.
                Но ключевой момент в том, что сравнивать субд и делать выбор просто по наличию нужной фичи сегодня
                некорректно, и нужно смотреть глубже
            </aside>
        </section>

        <section>
            <h3 class="r-fit-text">Процессы и потоки</h3>
            <aside class="notes"></aside>
        </section>

        <section>
            <h3 class="slide-header">Процессы PostgreSQL</h3>
            <img class="r-stretch" src="static/img/pg_process_model.png" alt="postgres process model"/>
            <aside class="notes">
                Под "PostgreSQL server" обычно подразумевается набор процессов:
                <ul>
                    <li>Процесс "postgres server" (ранее postmaster), являющийся родительским для всех остальных
                        процессов
                    </li>
                    <li>Процессы postgres backend", которые создаются под каждое соединение</li>
                    <li>Набор служебных процессов, отвечающих за разные компоненты и функции сервера</li>
                    <li>А взаимодействуют они все через общую память</li>
                </ul>
            </aside>
        </section>

        <section>
            <h3 class="slide-header">Процессы PostgreSQL</h3>
            <pre><code class="language-plaintext" style="font-size: 11pt" data-line-numbers="|1-3|10-11|4-9">$ pstree -p 43545
-+= 00001 root /sbin/launchd
 \-+= 43545 n.strelkov /usr/local/bin/postgres -D /usr/local/var/postgres
   |--= 43547 n.strelkov postgres: checkpointer
   |--= 43548 n.strelkov postgres: background writer
   |--= 43549 n.strelkov postgres: walwriter
   |--= 43550 n.strelkov postgres: autovacuum launcher
   |--= 43551 n.strelkov postgres: stats collector
   |--= 43552 n.strelkov postgres: logical replication launcher
   |--= 48886 n.strelkov postgres: n.strelkov postgres [local] idle
   \--= 49086 n.strelkov postgres: n.strelkov movielens [local] idle in transaction
            </code></pre>
            <aside class="notes">
                Вот я для примера на своем ноуте запустил postgres server, <br>
                открыл два терминала, <br>
                подключился в них консольным клиентом psql к серверу, <br>
                и распечатал показания утилиты pstree для основого процесса postgres server<br>
                Посмотрим повнимательнее: <br>
                В 3 строке мы как раз видим основной процесс Postgres Server <br>
                Который в свою очередь породил два дочерних backend процесса на каждое соединение, установленное через
                psql <br>
                Один висит и ничего не делает, а второй висит с открытой в нем транзакцией<br>
                А также мы видим набор служебных процессов для различных функций
            </aside>
        </section>

        <section>
            <h3 class="slide-header">Процессы MySQL</h3>
            <pre><code class="language-plaintext" style="font-size: 14pt" data-line-numbers="|3-4|5-11">$ pstree -p 50249
-+= 00001 root /sbin/launchd
 \-+= 50136 n.strelkov /bin/sh /usr/local/opt/mysql/bin/mysqld_safe \
                --datadir=/usr/local/var/mysql
   \--- 50249 n.strelkov /usr/local/opt/mysql/bin/mysqld \
                --basedir=/usr/local/opt/mysql \
                --datadir=/usr/local/var/mysql \
                --plugin-dir=/usr/local/opt/mysql/lib/plugin \
                --log-error=n-strelkov.err \
                --pid-file=n-strelkov.pid
            </code></pre>
            <aside class="notes">
                Те же подготовительные операции я проделал с mysql сервером <br>
                но тут мы уже видим всего один основной и один дочерний процесс <br>
                mysqld_safe - это просто дополнительная обертка рекомендованная для запуска mysql сервера в
                UNIX-подобных ОС <br>
                но ключевое тут то, что несмотря на два подключенных клиента мы не видим процессы, как так? :)
            </aside>
        </section>

        <section>
            <h3 class="slide-header">Потоки MySQL</h3>
            <pre><code class="language-plaintext" style="font-size: 10pt" data-line-numbers="|2-10|11-19|20-29|12">mysql> show processlist\G
*************************** 1. row ***************************
     Id: 5
   User: event_scheduler
   Host: localhost
     db: NULL
Command: Daemon
   Time: 539
  State: Waiting on empty queue
   Info: NULL
*************************** 2. row ***************************
     Id: 8
   User: root
   Host: localhost
     db: NULL
Command: Query
   Time: 0
  State: init
   Info: show processlist
*************************** 3. row ***************************
     Id: 9
   User: root
   Host: localhost
     db: NULL
Command: Sleep
   Time: 437
  State:
   Info: NULL
3 rows in set (0.00 sec)</code></pre>
            <aside class="notes"></aside>
        </section>

        <section>
            <h3 class="slide-header">MySQL</h3>
            <p>Connection ID</p>
            <pre><code class="language-plaintext" data-line-numbers="|3">mysql> select connection_id()\G
*************************** 1. row ***************************
connection_id(): 8
1 row in set (0.01 sec)</code></pre>
            <aside class="notes"></aside>
        </section>

        <section>
            <h3 class="slide-header">MySQL</h3>
            <p>количество активных потоков</p>
            <pre><code class="language-plaintext" data-line-numbers="|3-4">mysql> show global status like 'threads_running'\G
*************************** 1. row ***************************
Variable_name: Threads_running
        Value: 2
1 row in set (0.00 sec)</code></pre>
            <aside class="notes"></aside>
        </section>

        <section>
            <h3 class="slide-header">Connection pool</h3>
            <table class="r-fit-text">
                <thead>
                <tr>
                    <th>PostgreSQL</th>
                    <th>MySQL</th>
                </tr>
                </thead>
                <tbody>
                <tr>
                    <td><a href="https://www.pgpool.net/">PGPool-II</a> <br>и/или<br> <a
                            href="https://www.pgbouncer.org/">PgBouncer</a></td>
                    <td>Client-side<br>connection pool</td>
                </tr>

                </tbody>

            </table>
            <aside class="notes">Не забывать настраивать пулл соединений с СУБД<br>
                Для PG в качестве прослойки обычно используются вот эти две утилиты<br>
                причем можно по отдельности, а можно и вместе, так как они имеют свои особенности и ограничения<br>
                А для MySQL сервер умеет кэшировать однажды выделенные на соединение потоки, поэтому тут нужно просто
            </aside>
        </section>

        <section>
            <h3 class="slide-header">Путь запроса PostgreSQL</h3>
            <img class="r-stretch" src="static/img/pg_query_path.png" alt="pg query path">
            <aside class="notes">
                <ol>
                    <li>Прикладная программа устанавливает подключение к серверу PostgreSQL. Эта программа передаёт
                        запрос на сервер и ждёт от него результатов.
                    </li>

                    <li>На этапе разбора запроса сервер выполняет синтаксическую проверку запроса, переданного
                        прикладной программой, и создаёт дерево запроса.
                    </li>

                    <li>Система правил принимает дерево запроса, созданное на стадии разбора, и ищет в системных
                        каталогах правила для применения к этому дереву.
                        Обнаружив подходящие правила, она выполняет преобразования, заданные в теле правил.
                        Одно из применений системы правил заключается в реализации представлений. Когда выполняется
                        запрос к представлению (т. е. виртуальной таблице),
                        система правил преобразует запрос пользователя в запрос, обращающийся не к представлению, а к
                        базовым таблицам из определения представления.
                    </li>

                    <li>Планировщик/оптимизатор принимает дерево запроса (возможно, переписанное) и создаёт план
                        запроса, который будет передан исполнителю.
                        Он выбирает план, сначала рассматривая все возможные варианты получения одного и того же
                        результата.
                        Например, если для обрабатываемого отношения создан индекс, прочитать отношение можно двумя
                        способами.
                        Во-первых, можно выполнить простое последовательное сканирование,
                        а во-вторых, можно использовать индекс.
                        Затем оценивается стоимость каждого варианта и выбирается самый дешёвый.
                        Затем выбранный вариант разворачивается в полноценный план, который сможет использовать
                        исполнитель.
                    </li>

                    <li>Исполнитель рекурсивно проходит по дереву плана и получает строки тем способом, который указан в
                        плане.
                        Он сканирует отношения, обращаясь к системе хранения, выполняет сортировку и соединения,
                        вычисляет условия фильтра и, наконец, возвращает полученные строки.
                    </li>
                </ol>

            </aside>
        </section>

        <section>
            <h3 class="slide-header">Путь запроса MySQL</h3>
            <img class="r-stretch" src="static/img/mysql_query_path.png" alt="mysql query path">
            <aside class="notes">
                Схема немного другая, но если присмотреться, то суть примерно та же. Отдельные компоненты, отвечают за:
                <ul>
                    <li>парсинг или синтаксический разбор</li>
                    <li>семантический разбор и подготовку запроса</li>
                    <li>планирование и оптимизацию</li>
                    <li>выполнение запроса</li>
                </ul>
                Но обратите внимание на один важный нюанс:<br>
                executor выполняет запрос к компоненту под названием Storage Engine через специальное API<br>
                А что такое API? Это интерфейс абстрагирующий клиента, в данном случае исполнителя и оптимизатор, от
                реализации хранилища.
            </aside>
        </section>

        <section>
            <h3 class="r-fit-text">Статистика</h3>
            <aside class="notes"></aside>
        </section>

        <section>
            <h3 class="slide-header">Статистика по таблицам</h3>
            <table class="r-fit-text">
                <thead>
                <tr>
                    <th>MySQL</th>
                    <th>PostgreSQL</th>
                </tr>
                </thead>
                <tbody>
                <tr>
                    <td>Размер кластерного индекса</td>
                    <td>Размер таблицы</td>
                </tr>
                <tr>
                    <td>количество строк</td>
                    <td>количество строк</td>
                </tr>
                <tr>
                    <td></td>
                    <td>количество страниц в памяти</td>
                </tr>
                </tbody>
            </table>
            <aside class="notes">
            </aside>
        </section>

        <section>
            <h3 class="slide-header">Статистика по атрибутам</h3>
            <table class="r-fit-text" style="table-layout: fixed; width: 100%;">
                <thead>
                <tr>
                    <th>MySQL</th>
                    <th>PostgreSQL</th>
                </tr>
                </thead>
                <tbody>
                <tr>
                    <td>Распределение данных, в т.ч. доля null значений</td>
                    <td>Доля null значение</td>
                </tr>
                <tr>
                    <td></td>
                    <td>Средний размер колонки в байтах</td>
                </tr>
                <tr>
                    <td></td>
                    <td>Количество уникальных значений</td>
                </tr>
                <tr>
                    <td></td>
                    <td>Статистическая корреляция между физическим порядком строк и логическим порядком значений
                        столбца
                    </td>
                </tr>
                <tr>
                    <td></td>
                    <td>Распределение данных</td>
                </tr>
                <tr>
                    <td></td>
                    <td>Наиболее часто встречаемые значения и их частота</td>
                </tr>
                </tbody>
            </table>
            <aside class="notes">
            </aside>
        </section>

        <section>
            <h3 class="slide-header">Межатрибутная статистика</h3>
            <table style="table-layout: fixed; width: 100%;">
                <thead>
                <tr>
                    <th>MySQL</th>
                    <th>PostgreSQL</th>
                </tr>
                </thead>
                <tbody>
                <tr>
                    <td></td>
                    <td>Функциональные зависимости</td>
                </tr>
                <tr>
                    <td></td>
                    <td>Количество уникальных значений</td>
                </tr>
                </tbody>
            </table>
            <aside class="notes">
                И вот именно благодаря тому, что postgres может собирать больше статистики, он в среднем лучше подходит
                для сложных аналитических запросов<br>
                С большим количеством join, агрегациями, табличными выражениями и тд
            </aside>
        </section>

        <section>
            <dl style="display: block; text-align: center;">
                <dt><strong style="font-size: 50pt; color: #0075ff">A</strong>tomicity - Атомарность</dt>
            </dl>
            <dl style="display: block; text-align: center;">
                <dt><strong style="font-size: 50pt; color: #0075ff">C</strong>onsistency - Согласованность</dt>
            </dl>
            <dl style="display: block; text-align: center;">
                <dt><strong style="font-size: 50pt; color: #0075ff">I</strong>solation - Изолированность</dt>
            </dl>
            <dl style="display: block; text-align: center;">
                <dt><strong style="font-size: 50pt; color: #0075ff">D</strong>urability - Долговечность</dt>
            </dl>
            <aside class="notes">
                <dl>
                    <dt>Атомарность</dt>
                    <dd>Атомарность гарантирует, что никакая транзакция не будет зафиксирована в системе частично</dd>
                </dl>
                <dl>
                    <dt>Согласованность</dt>
                    <dd>каждая успешная транзакция по определению фиксирует только допустимые результаты</dd>
                </dl>
                <dl>
                    <dt>Изолированность</dt>
                    <dd>Во время выполнения транзакции параллельные транзакции не должны оказывать влияние на её
                        результат
                    </dd>
                </dl>
                <dl>
                    <dt>Долговечность</dt>
                    <dd>изменения, сделанные успешно завершённой транзакцией, должны остаться сохранёнными после
                        возвращения системы в работу
                    </dd>
                </dl>
            </aside>
        </section>

        <section>
            <h3 class="slide-header">MVCC</h3>
            <p>Multi Version Concurrency Control</p>

            <aside class="notes">
                MVCC это подход к организации конкурентной обработки данных, основанный на идее одновременного хранения
                нескольких версий объекта, так чтобы операции чтения и записи не конфликтовали
                <br>
                Под операцией записи имеется ввиду UPDATE и DELETE, так как только что добавленная новая запись
                по-умолчанию будет защищена от других транзакций
                <br>
                Each WRITE operation produces a new version of the object and each concurrent read operation
                reads a different version of the object depending on the isolation level. Since read and write both
                operating on different versions of the same object so none of these operations required to completely
                lock and hence both can operate concurrently. The only case where the contention can still exist is when
                two concurrent transaction tries to WRITE the same record.

                Most of the current major database supports MVCC. The intention of this algorithm is maintaining
                multiple versions of the same object so the implementation of MVCC differs from database to database
                only in terms of how multiple versions are created and maintained. Accordingly, corresponding database
                operation and storage of data changes.

                Most recognized approach to implements MVCC is the one used by PostgreSQL and Firebird/Interbase and
                another one is used by InnoDB and Oracle. In subsequent sections, we will discuss in detail how it has
                been implemented in PostgreSQL and InnoDB.
            </aside>
        </section>

        <section>
            <h3 class="slide-header">MVCC PostgreSQL</h3>
            <img class="r-fit-text" src="static/img/mvcc_pg.png" alt="pg mvcc">
            <aside class="notes"></aside>
        </section>

        <section class="slide">
            <h3 class="slide-header">MVCC 1: TABLE</h3>
            <table class="r-fit-text">
                <thead>
                <tr>
                    <th>action</th>
                    <th>
                        <div class="label-r">TXID: 103</div>
                        xmin
                    </th>
                    <th>xmax</th>
                    <th>id</th>
                    <th>name</th>
                    <th>notes</th>
                </tr>
                </thead>
                <tbody>
                <tr>
                    <td></td>
                    <td>100</td>
                    <td>0</td>
                    <td>1</td>
                    <td>Alice</td>
                    <td>Great at programming</td>
                </tr>
                <tr>
                    <td></td>
                    <td>101</td>
                    <td>0</td>
                    <td>2</td>
                    <td>Bob</td>
                    <td>Always talk to alice</td>
                </tr>
                <tr>
                    <td></td>
                    <td>102</td>
                    <td>0</td>
                    <td>3</td>
                    <td>Eve</td>
                    <td>Listens to everyone's conversations</td>
                </tr>
                </tbody>
            </table>
        </section>

        <section class="slide">
            <h3 class="slide-header">MVCC 2: UPDATE</h3>
            <table class="r-fit-text">
                <thead>
                <tr>
                    <th>action</th>
                    <th>
                        <div class="label-r">TXID: 103</div>
                        xmin
                    </th>
                    <th>xmax</th>
                    <th>id</th>
                    <th>name</th>
                    <th>notes</th>
                </tr>
                </thead>
                <tbody>
                <tr>
                    <td></td>
                    <td>100</td>
                    <td>0</td>
                    <td>1</td>
                    <td>Alice</td>
                    <td>Great at programming</td>
                </tr>
                <tr class="update">
                    <td>- update</td>
                    <td>101</td>
                    <td>0</td>
                    <td>2</td>
                    <td>Bob</td>
                    <td>Always talk to alice</td>
                </tr>
                <tr>
                    <td></td>
                    <td>102</td>
                    <td>0</td>
                    <td>3</td>
                    <td>Eve</td>
                    <td>Listens to everyone's conversations</td>
                </tr>
                </tbody>
            </table>
        </section>

        <section class="slide">
            <h3 class="slide-header">MVCC 3: UPDATE IN PROGRESS</h3>
            <table class="r-fit-text">
                <thead>
                <tr>
                    <th>action</th>
                    <th>
                        <div class="label-r">TXID: 103</div>
                        xmin
                    </th>
                    <th>xmax</th>
                    <th>id</th>
                    <th>name</th>
                    <th>notes</th>
                </tr>
                </thead>
                <tbody>
                <tr>
                    <td></td>
                    <td>100</td>
                    <td>0</td>
                    <td>1</td>
                    <td>Alice</td>
                    <td>Great at programming</td>
                </tr>
                <tr class="update obsolete">
                    <td>- update</td>
                    <td>101</td>
                    <td class="changed">103</td>
                    <td>2</td>
                    <td>Bob</td>
                    <td>Always talk to alice</td>
                </tr>
                <tr>
                    <td></td>
                    <td>102</td>
                    <td>0</td>
                    <td>3</td>
                    <td>Eve</td>
                    <td>Listens to everyone's conversations</td>
                </tr>
                </tbody>
            </table>
        </section>

        <section class="slide">
            <h3 class="slide-header">MVCC 4: UPDATE IN PROGRESS</h3>
            <table class="r-fit-text">
                <thead>
                <tr>
                    <th>action</th>
                    <th>
                        <div class="label-r">TXID: 103</div>
                        xmin
                    </th>
                    <th>xmax</th>
                    <th>id</th>
                    <th>name</th>
                    <th>notes</th>
                </tr>
                </thead>
                <tbody>
                <tr>
                    <td></td>
                    <td>100</td>
                    <td>0</td>
                    <td>1</td>
                    <td>Alice</td>
                    <td>Great at programming</td>
                </tr>
                <tr class="update obsolete">
                    <td>- update</td>
                    <td>101</td>
                    <td class="changed">103</td>
                    <td>2</td>
                    <td>Bob</td>
                    <td>Always talk to alice</td>
                </tr>
                <tr>
                    <td></td>
                    <td>102</td>
                    <td>0</td>
                    <td>3</td>
                    <td>Eve</td>
                    <td>Listens to everyone's conversations</td>
                </tr>
                <tr class="update changed">
                    <td>+ update</td>
                    <td>103</td>
                    <td>0</td>
                    <td>2</td>
                    <td>Bob</td>
                    <td>Working very hard</td>
                </tr>
                </tbody>
            </table>
        </section>

        <section class="slide">
            <h3 class="slide-header">MVCC 5: UPDATED</h3>
            <table class="r-fit-text">
                <thead>
                <tr>
                    <th>action</th>
                    <th>
                        <div class="label-r">TXID: 104</div>
                        xmin
                    </th>
                    <th>xmax</th>
                    <th>id</th>
                    <th>name</th>
                    <th>notes</th>
                </tr>
                </thead>
                <tbody>
                <tr>
                    <td></td>
                    <td>100</td>
                    <td>0</td>
                    <td>1</td>
                    <td>Alice</td>
                    <td>Great at programming</td>
                </tr>
                <tr class="update obsolete">
                    <td></td>
                    <td>101</td>
                    <td class="changed">103</td>
                    <td>2</td>
                    <td>Bob</td>
                    <td>Always talk to alice</td>
                </tr>
                <tr>
                    <td></td>
                    <td>102</td>
                    <td>0</td>
                    <td>3</td>
                    <td>Eve</td>
                    <td>Listens to everyone's conversations</td>
                </tr>
                <tr class="update changed">
                    <td></td>
                    <td>103</td>
                    <td>0</td>
                    <td>2</td>
                    <td>Bob</td>
                    <td>Working very hard</td>
                </tr>
                </tbody>
            </table>
        </section>

        <section class="slide">
            <h3 class="slide-header">MVCC 6: INSERT</h3>
            <table class="r-fit-text">
                <thead>
                <tr>
                    <th>action</th>
                    <th>
                        <div class="label-r">TXID: 104</div>
                        xmin
                    </th>
                    <th>xmax</th>
                    <th>id</th>
                    <th>name</th>
                    <th>notes</th>
                </tr>
                </thead>
                <tbody>
                <tr>
                    <td></td>
                    <td>100</td>
                    <td>0</td>
                    <td>1</td>
                    <td>Alice</td>
                    <td>Great at programming</td>
                </tr>
                <tr class="update obsolete">
                    <td></td>
                    <td>101</td>
                    <td class="changed">103</td>
                    <td>2</td>
                    <td>Bob</td>
                    <td>Always talk to alice</td>
                </tr>
                <tr>
                    <td></td>
                    <td>102</td>
                    <td>0</td>
                    <td>3</td>
                    <td>Eve</td>
                    <td>Listens to everyone's conversations</td>
                </tr>
                <tr class="update changed">
                    <td></td>
                    <td>103</td>
                    <td>0</td>
                    <td>2</td>
                    <td>Bob</td>
                    <td>Working very hard</td>
                </tr>
                <tr class="insert">
                    <td>+ insert</td>
                    <td>104</td>
                    <td>0</td>
                    <td>4</td>
                    <td>Dave</td>
                    <td>Very promising new-hire</td>
                </tr>
                </tbody>
            </table>
        </section>

        <section class="slide">
            <h3 class="slide-header">MVCC 7: INSERTED</h3>
            <table class="r-fit-text">
                <thead>
                <tr>
                    <th>action</th>
                    <th>
                        <div class="label-r">TXID: 105</div>
                        xmin
                    </th>
                    <th>xmax</th>
                    <th>id</th>
                    <th>name</th>
                    <th>notes</th>
                </tr>
                </thead>
                <tbody>
                <tr>
                    <td></td>
                    <td>100</td>
                    <td>0</td>
                    <td>1</td>
                    <td>Alice</td>
                    <td>Great at programming</td>
                </tr>
                <tr class="update obsolete">
                    <td></td>
                    <td>101</td>
                    <td class="changed">103</td>
                    <td>2</td>
                    <td>Bob</td>
                    <td>Always talk to alice</td>
                </tr>
                <tr>
                    <td></td>
                    <td>102</td>
                    <td>0</td>
                    <td>3</td>
                    <td>Eve</td>
                    <td>Listens to everyone's conversations</td>
                </tr>
                <tr class="update changed">
                    <td></td>
                    <td>103</td>
                    <td>0</td>
                    <td>2</td>
                    <td>Bob</td>
                    <td>Working very hard</td>
                </tr>
                <tr class="insert">
                    <td></td>
                    <td>104</td>
                    <td>0</td>
                    <td>4</td>
                    <td>Dave</td>
                    <td>Very promising new-hire</td>
                </tr>
                </tbody>
            </table>
        </section>

        <section class="slide">
            <h3 class="slide-header">MVCC 8: DELETE</h3>
            <table class="r-fit-text">
                <thead>
                <tr>
                    <th>action</th>
                    <th>
                        <div class="label-r">TXID: 105</div>
                        xmin
                    </th>
                    <th>xmax</th>
                    <th>id</th>
                    <th>name</th>
                    <th>notes</th>
                </tr>
                </thead>
                <tbody>
                <tr>
                    <td></td>
                    <td>100</td>
                    <td>0</td>
                    <td>1</td>
                    <td>Alice</td>
                    <td>Great at programming</td>
                </tr>
                <tr class="update obsolete">
                    <td></td>
                    <td>101</td>
                    <td class="changed">103</td>
                    <td>2</td>
                    <td>Bob</td>
                    <td>Always talk to alice</td>
                </tr>
                <tr class="delete obsolete">
                    <td>- delete</td>
                    <td>102</td>
                    <td>105</td>
                    <td>3</td>
                    <td>Eve</td>
                    <td>Listens to everyone's conversations</td>
                </tr>
                <tr class="update changed">
                    <td></td>
                    <td>103</td>
                    <td>0</td>
                    <td>2</td>
                    <td>Bob</td>
                    <td>Working very hard</td>
                </tr>
                <tr class="insert">
                    <td></td>
                    <td>104</td>
                    <td>0</td>
                    <td>4</td>
                    <td>Dave</td>
                    <td>Very promising new-hire</td>
                </tr>
                </tbody>
            </table>
        </section>

        <section class="slide">
            <h3 class="slide-header">MVCC 9: DELETED</h3>
            <table class="r-fit-text">
                <thead>
                <tr>
                    <th>action</th>
                    <th>
                        <div class="label-r">TXID: 106</div>
                        xmin
                    </th>
                    <th>xmax</th>
                    <th>id</th>
                    <th>name</th>
                    <th>notes</th>
                </tr>
                </thead>
                <tbody>
                <tr>
                    <td></td>
                    <td>100</td>
                    <td>0</td>
                    <td>1</td>
                    <td>Alice</td>
                    <td>Great at programming</td>
                </tr>
                <tr class="update obsolete">
                    <td></td>
                    <td>101</td>
                    <td class="changed">103</td>
                    <td>2</td>
                    <td>Bob</td>
                    <td>Always talk to alice</td>
                </tr>
                <tr class="delete obsolete">
                    <td></td>
                    <td>102</td>
                    <td>105</td>
                    <td>3</td>
                    <td>Eve</td>
                    <td>Listens to everyone's conversations</td>
                </tr>
                <tr class="update changed">
                    <td></td>
                    <td>103</td>
                    <td>0</td>
                    <td>2</td>
                    <td>Bob</td>
                    <td>Working very hard</td>
                </tr>
                <tr class="insert">
                    <td></td>
                    <td>104</td>
                    <td>0</td>
                    <td>4</td>
                    <td>Dave</td>
                    <td>Very promising new-hire</td>
                </tr>
                </tbody>
            </table>
        </section>

        <section>
            <h3 class="slide-header">MVCC MySQL InnoDB</h3>
            <img class="r-fit-text" src="static/img/mvcc_innodb.png" alt="mysql innodb mvcc" style="margin-top: -15px;">
            <aside class="notes">
                In order to support multiple versions, InnoDB maintains additional fields for each row as mentioned
                below:

                DB_TRX_ID: Transaction ID of the transaction which inserted or updated the row.
                DB_ROLL_PTR: It is also called the roll pointer and it points to undo log record written to the rollback
                segment (more on this next).
                Like PostgreSQL, InnoDB also creates multiple versions of the row as part of all operation but the
                storage of the older version is different.

                In case of InnoDB, the old version of the changed row is kept in a separate tablespace/storage (called
                undo segment). <b>So unlike PostgreSQL, InnoDB keeps only the latest version of rows in the main storage
                area and the older version is kept in the undo segment.</b> Row versions from the undo segment are used
                to undo operation in case of rollback and for reading an older version of rows by READ statement
                depending on the isolation level.

                Consider there are two rows, T1 (with value 1) and T2 (with value 2) for a table, the creation of new
                rows can be demonstrated in below 3 steps:

                As seen from the figure, initially there are two rows in the database with values 1 and 2.

                Then in as per second stage, the row T2 with value 2 gets updated with the value 3. At this point, a new
                version is created with the new value and it replaces the older version. Before that, the older version
                gets stored in the undo segment (notice the UNDO segment version has only a delta value). Also, note
                that there is one pointer from the new version to the older version in the rollback segment. So unlike
                PostgreSQL, InnoDB update is “IN-PLACE”.

                Similarly, in the third step, when row T1 with value 1 gets deleted, then the existing row gets
                virtually deleted (i.e. it just marks a special bit in the row) in the main storage area and a new
                version corresponding to this gets added in the Undo segment. Again, there is one roll pointer from the
                main storage to the undo segment.

                All operations behave in the same way as in the case of PostgreSQL when seen from outside. Just internal
                storage of multiple version differs.

            </aside>
        </section>

        <section>
            <h3 class="slide-header">Сравнение реализаций MVCC</h3>
            <ol>
                <li>Размер старой версии объекта</li>
                <li>INSERT</li>
                <li>Восстановление предыдущей версии в случае отката транзакции</li>
                <li>Освобождение места занятого старой версией</li>
                <li>Влияние задержек очистки мертвых кортежей</li>
                <li>Последовательное сканирование "распухшей таблицы"</li>
                <li>Индексы</li>
            </ol>
            <aside class="notes">
                <ol>
                    <li>
                        Size of an older version
                        PostgreSQL just updates xmax on the older version of the tuple, so the size of the older version
                        remains the same to the corresponding inserted record. This means if you have 3 versions of an
                        older tuple then all of them will have the same size (except the difference in actual data size
                        if any at each update).

                        Whereas in case of InnoDB, the object version stored in the Undo segment is typically smaller
                        than the corresponding inserted record. This is because only the changed values (i.e.
                        differential) are written to UNDO log.
                    </li>
                    <li>
                        INSERT operation
                        InnoDB needs to write one additional record in the UNDO segment even for INSERT whereas
                        PostgreSQL creates new version only in case of UPDATE.
                    </li>
                    <li>
                        Restoring an older version in case of rollback
                        PostgreSQL does not need to anything specific in order to restore an older version in case of
                        rollback. Remember the older version has xmax equal to the transaction which updated this tuple.
                        So, till this transaction id gets committed, it is considered to be alive tuple for a concurrent
                        snapshot. Once the transaction is rollbacked, the corresponding transaction will be
                        automatically considered alive for all transaction as it will be an aborted transaction.
                        Whereas in case of InnoDB, it is explicitly required to rebuild the older version of the object
                        once rollback happens.
                    </li>
                    <li>
                        Reclaiming space occupied by an older version
                        In case of PostgreSQL, the space occupied by an older version can be considered dead only when
                        there is no parallel snapshot to read this version. Once the older version is dead, then the
                        VACUUM operation can reclaim the space occupied by them. VACUUM can be triggered manually or as
                        a background task depending on the configuration.
                        InnoDB UNDO logs are primarily divided into INSERT UNDO and UPDATE UNDO. The first one gets
                        discarded as soon as the corresponding transaction commits. The second one needs to preserve
                        till it is parallel to any other snapshot. InnoDB does not have explicit VACUUM operation but on
                        a similar line it has asynchronous PURGE to discard UNDO logs which runs as a background task.
                    </li>
                    <li> Impact of delayed vacuum
                        As discussed in a previous point, there is a huge impact of delayed vacuum in case of
                        PostgreSQL. It causes the table to start bloating and causing storage space to increase even
                        though records are constantly deleted. It may also reach a point where VACUUM FULL needs to be
                        done which is very costly operations.
                    </li>
                    <li> Sequential scan in case of bloated table
                        PostgreSQL sequential scan must traverse through all older version of an object even though all
                        of them
                        are dead (till they are removed using vacuum). This is the typical and most talked about problem
                        in
                        PostgreSQL. Remember PostgreSQL stores all versions of a tuple in the same storage.
                        Whereas in case of InnoDB, it does not need to read Undo record unless it is required. In case
                        all undo
                        records are dead, then it will be only enough to read through all the latest version of the
                        objects.
                    </li>
                    <li>
                        Index
                        PostgreSQL stores index in a separate storage which keeps one link to actual data in HEAP. So
                        PostgreSQL
                        has to update INDEX part also even though there was no change in INDEX. Though later this issue
                        was
                        fixed by implementing HOT (Heap Only Tuple) update but still it has the limitation that if a new
                        heap
                        tuple can’t be accommodated in the same page, then it fallback to normal UPDATE.

                        InnoDB does not have this problem as they use clustered index.
                    </li>
                </ol>
                <p> Conclusion
                    PostgreSQL MVCC has got few drawbacks especially in terms of bloated storage if your workload has
                    frequent UPDATE/DELETE. So if you decide to use PostgreSQL you should be very careful to configure
                    VACUUM wisely.

                    PostgreSQL community has also acknowledged this as a major issue and they have already started
                    working
                    on UNDO based MVCC approach (tentative name as ZHEAP) and we might see the same in a future release.
                </p>
            </aside>
        </section>

        <section>
            <h3 class="r-fit-text">Индексы</h3>
            <aside class="notes">
                Database Index, as the name suggests, maintains an index to the actual data and thereby improves
                performance to retrieve data from the actual table. In a more database terminology, the index allows
                fetching page containing indexed data in a very minimal traversal as data is sorted in specific order.
                Index benefit comes at the cost of additional storage space in order to write additional data. Indexes
                are specific to the underlying table and consist of one or more keys (i.e. one or more columns of the
                specified table). There are primarily two types of index architecture
            </aside>
        </section>

        <section>
            <h3 class="slide-header">Индекс</h3>
            <p>Два основных типа архитектуры индекса:</p>
            <ul>
                <li>Кластерный индекс</li>
                <li>Некластерный индекс</li>
            </ul>
            <aside class="notes"></aside>
        </section>

        <section>
            <h3 class="slide-header">Кластерный индекс</h3>
            <p>Проиндексированное значение хранится вместе с данными.</p>
            <p>Данные хранятся в отсортированном виде в порядке заданном индексом.</p>
            <p>У таблицы может быть только один индекс такого типа.</p>
            <aside class="notes"></aside>
        </section>

        <section>
            <h3 class="slide-header">Некластерный индекс</h3>
            <p>Проиндексированные значения и данные хранятся отдельно.</p>
            <p>Индекс содержит указатели на остальные данные строки.</p>
            <p>Так же известен, как "вторичный индекс" (secondary index).</p>
            <aside class="notes"></aside>
        </section>

        <section>
            <h3 class="slide-header">Индексы в PostgreSQL</h3>
            <p>Все индексы являются некластерными(вторичными), так как данные хранятся отдельно в табличной куче (Table
                Heap)</p>
            <img src="static/img/pg_index.png" alt="">
            <p>Есть механизм кластеризации данных по индексу</p>
            <aside class="notes">PostgreSQL supports only non-clustered index. That means index data and complete data
                (here onward referred to as heap data) are stored in a separate storage. Non-clustered indexes are like
                “Table of Content” in any document, wherein first we check the page number and then check those page
                numbers to read the whole content. In order to get the complete data based on an index, it maintains a
                pointer to corresponding heap data. It's the same as after knowing page number, it needs to go to that
                page and get the actual content of the page.

                For example, consider a table with three columns and an index on column ID. In order to READ the data
                based on the key ID=2, first, the Indexed data with the ID value 2 is searched. This contains a pointer
                (called as Item Pointer) in terms of the page number (i.e. block number) and offset of data within that
                page. In the current example, the index points to page number 5 and the second line item in the page
                which in turn keeps offset to the whole data(2,”Shaun”,100). Notice whole data also contains the indexed
                data which means the same data is repeated in two storages.

                How does INDEX help to improve performance? Well, in order to select any INDEX record, it does not scan
                all pages sequentially, rather it just needs to partially scan some of the pages using the underlying
                Index data structure. But there is a twist, since each record found from Index data, it needs to look in
                Heap data for whole data, which causes a lot of random I/O and it’s considered to perform slower than
                Sequential I/O. So only if a small percentage of records are getting selected (which decided based on
                the PostgreSQL optimizer Cost), then only PostgreSQL chooses Index Scan otherwise even though there is
                an index on the table, it continues to use Sequence Scan.

                In summary, though Index creation speeds up the performance ,it should be carefully chosen as it has
                overhead in terms of storage, degraded INSERT performance.

                Now we may wonder, in-case we need only the index part of data, can we fetch only from the index storage
                page? Well, the answer to this is directly related to how MVCC works on the index storage as explained
                next.

                Like Heap pages, index page maintains multiple versions of index tuple but it does not
                maintain visibility information. As explained in my previous MVCC blog, in order to decide suitable
                visible version of tuples, it requires comparing transaction. The transaction which
                inserted/updated/deleted tuple are maintained along with heap tuple but the same is not maintained with
                index tuple. This is purely done to save storage and it’s a trade-off between space and performance.

                Now coming back to the original question, since the visibility information in Index tuple is not there,
                it needs to consult the corresponding heap tuple to see if the data selected is visible. So even though
                other parts of the data from heap tuple is not required, still need to access the heap pages to check
                visibility. But again, there is a twist in-case all tuples on a given page (page pointed by index i.e.
                ItemPointer) are visible then does not need to refer each item of Heap page for “visibility check” and
                hence the data can be returned only from the Index page. This special case is called “Index Only Scan”.
                In order to support this, PostgreSQL maintains a visibility map for each page to check the page level
                visibility.
            </aside>
        </section>

        <section>
            <h3 class="slide-header">Индексы в PostgreSQL</h3>
            <p>Есть поддержка составных, частичных и функциональных индексов.</p>
            <pre><code class="" data-line-numbers="|1-2|4-5|7-8">CREATE INDEX idx_users_age_gender
                ON people(age, gender); -- составной

CREATE INDEX idx_users_age_partial
                ON people(age) where age >= 25; -- частичный

CREATE INDEX idx_users_names
                ON people(LOWER(name)); -- функциональный
            </code></pre>
            <aside class="notes">
            </aside>
        </section>

        <section>
            <h3 class="slide-header">Индексы в PostgreSQL</h3>
            <p>Большой выбор встроенных типов индексов:</p>
            <ul>
                <li>B-Tree Index</li>
                <li>Hash Index</li>
                <li>GIN (Generalized Inverted Index)</li>
                <li>GiST (Generalized Search Tree)</li>
                <li>SP-GiST (Space Partitioned GiST)</li>
                <li>(BRIN) Block Range Index</li>
            </ul>
            <aside class="notes"></aside>
        </section>

        <section>
            <h3 class="slide-header">Индексы в MySQL</h3>
            <p>В таблице может быть 1 кластерный и несколько некластерных вторичных индексов.</p>
            <img src="static/img/innodb_index.png" alt="">
            <aside class="notes">Clustered Index is a special kind of index in InnoDB. Here the indexed data is not
                stored separately rather it is part of the whole row data. In other words, the clustered index just
                forces the table data to be sorted physically using the key column of the index. It can be considered as
                “Dictionary”, where data is sorted based on the alphabet.

                Since the clustered index sort rows using an index key, there can be only one clustered index. Also,
                there must be one clustered index as InnoDB uses same to optimally manipulate data during various data
                operations.

                Clustered index are created automatically (as part of table create) using one of the table columns as
                per below priority:

                Using the primary key if the primary key is mentioned as part of the table creation.
                Chooses any unique column where all the key columns are NOT NULL.
                Otherwise internally generates a hidden clustered index on a system column which contains the row ID of
                each row.
                Unlike PostgreSQL non-clustered index, InnoDB access a row using clustered index faster because the
                index search leads directly to the page with all row data and hence avoiding random I/O.

                Also getting the table data in sorted order using the clustered index is very fast as all data are
                already sorted and also whole data is available.
            </aside>
        </section>

        <section>
            <h3 class="slide-header">Индексы в MySQL</h3>
            <ul>
                <li>Поддерживает в явном виде только B+ Tree тип индекса.</li>
                <li>Hash индексы используются самим движком InnoDB в служебных целях.</li>
                <li>Поддерживает Index Hints</li>
            </ul>
            <pre><code class="" data-line-numbers="|">SELECT * FROM table1 USE INDEX (col1_index,col2_index)
  WHERE col1=1 AND col2=2 AND col3=3;

SELECT * FROM table1 IGNORE INDEX (col3_index)
  WHERE col1=1 AND col2=2 AND col3=3;
            </code></pre>
            <aside class="notes"></aside>
        </section>

        <section>
            <h3 class="r-fit-text">Спасибо за внимание!</h3>
            <footer>Вопросы, пожелания, предложения, замечания и критику прошу направлять сюда:
                <ul style="list-style: none;">
                    <li><a href="mailto:nikita.strelkov@gmail.com">nikita.strelkov@gmail.com</a></li>
                    <li>Telegram: <a href="https://t.me/nikitastrelkov">@NikitaStrelkov</a></li>
                </ul>
            </footer>
            <aside class="notes"></aside>
        </section>

        <section>
            <p>Материалы:</p>
            <ul>
                <li><a href="https://dev.mysql.com/doc/internals/en/innodb.html">MySQL Internals Documentation</a></li>
                <li><a href="https://www.postgresql.org/docs/current/internals.html">Postgres Internals
                    Documentation</a></li>
                <li><a href="https://www.interdb.jp/pg/">The Internals of PostgreSQL by Hironobu Suziki</a></li>
                <li><a href="https://severalnines.com/database-blog/comparing-data-stores-postgresql-mvcc-vs-innodb">Comparing
                    data stores postgresql mvcc vs innodb</a></li>
                <li>
                    <a href="https://severalnines.com/database-blog/postgresql-index-vs-innodb-index-understanding-differences">Postgresql
                        index vs innodb index understanding differences</a></li>
                <li><a href="https://github.com/ChrisAntognini">https://github.com/ChrisAntognini</a></li>
            </ul>
            <aside class="notes"></aside>
        </section>
    </div>
</div>

<script src="reveal.js/dist/reveal.js"></script>
<script src="reveal.js/plugin/notes/notes.js"></script>
<script src="reveal.js/plugin/markdown/markdown.js"></script>
<script src="reveal.js/plugin/highlight/highlight.js"></script>
<script>
    // More info about initialization & config:
    // - https://revealjs.com/initialization/
    // - https://revealjs.com/config/
    Reveal.initialize({
        hash: true,

        // Learn about plugins: https://revealjs.com/plugins/
        plugins: [RevealMarkdown, RevealHighlight, RevealNotes],

        slideNumber: 'c',
        showSlideNumber: 'all',
    });
</script>
</body>
</html>
